#
# Copyright © 2024 QPerfect. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import csv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

"""
Simulator Benchmark Analysis: Scalability - Maximum Qubits by each Simulator on each Circuit
----------------------------------------------------

This script reads benchmark data from a CSV file ("benchmark_max_qubits.csv" - generated by script create-table-from-json.py)
that contains the maximum number of qubits achieved by various simulators for
different algorithms. It processes the CSV data—ensuring each row conforms to the
expected format — and converts the numerical values appropriately. The script then
generates a radar chart (polar plot) to visualize and compare the achieved scalability of
each simulator.

Prerequisites:
- Python packages: csv, numpy, pandas, matplotlib.
- A properly formatted CSV file ("benchmark_max_qubits.csv") using ";" as the delimiter.
- For created "benchmark_max_qubits.csv" - use the script script create-table-from-json.py.

Configuration:
- Visual Style:
  The script selects a preferred visual style from matplotlib ("seaborn-whitegrid" or "ggplot")
  or falls back to the default style.
- Simulator Settings:
  Customize simulator-specific visualization by modifying the 'color_map' and 'marker_shapes'
  dictionaries. Add or update entries as new simulators are introduced.
- Data Processing:
  The script filters out empty rows and adjusts row lengths to match the expected number of columns.
- Radar Chart Customization:
  The 'alg' column provides the labels for each axis of the radar chart.
  A symlog scale is used for the radial axis with predefined tick values.
  Overlapping markers are slightly offset to improve readability.

Result: "radar_chart.png"

Usage:
1. Ensure that all prerequisites are met and the CSV file is located in the current directory.
2. Adjust configuration settings (simulator mappings) as needed.
3. Run the script to generate the radar chart. The final chart is saved as "radar_chart.png".

Notes:
- Modify the CSV file path, simulator dictionaries, or chart settings to best fit your benchmark data.
"""

import os
import csv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from matplotlib.lines import Line2D

import os
import csv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
from matplotlib.lines import Line2D

# Choose a visual style 
if "seaborn-whitegrid" in plt.style.available:
    plt.style.use("seaborn-whitegrid")
elif "ggplot" in plt.style.available:
    plt.style.use("ggplot")
else:
    plt.style.use("default")

def darken_color(hex_color, factor=0.8):
    """
    Darkens the given hex color by the given factor.
    A factor of 0.8 returns a color with 80% brightness.
    """
    hex_color = hex_color.lstrip('#')
    rgb = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    darkened_rgb = tuple(max(0, int(c * factor)) for c in rgb)
    return '#' + ''.join(f'{c:02x}' for c in darkened_rgb)

# Define benchmarks to delete.
delete_bench = ["twolocal"]

expected_cols = 10 
rows = []
with open("benchmark_max_qubits.csv", "r", encoding="utf-8-sig") as f:
    reader = csv.reader(f, delimiter=";")
    for row in reader:
        row = [field.strip() for field in row]
        if not row or all(field == "" for field in row):
            continue
        if len(row) < expected_cols:
            row += [""] * (expected_cols - len(row))
        elif len(row) > expected_cols:
            row = row[:expected_cols]
        rows.append(row)

header = rows[0]
data = rows[1:]
df = pd.DataFrame(data, columns=header)

# Filter out rows with benchmarks we want to delete.
df = df[~df["alg"].isin(delete_bench)]

def convert_value(x):
    if not isinstance(x, str):
        try:
            x = str(x)
        except Exception:
            return np.nan
    if x == "":
        return np.nan
    s = x.strip()
    if "," in s:
        s = s.replace(",", ".")  
    try:
        return float(s)
    except Exception:
        return np.nan

# Filter out empty simulator columns
simulator_cols = [col for col in header[2:] if col.strip() != '']

for col in simulator_cols:
    df[col] = df[col].apply(convert_value)

alg_labels = df["alg"].tolist()
num_algs = len(alg_labels)
angles = np.linspace(0, 2 * np.pi, num_algs, endpoint=False)
angles_closed = np.concatenate((angles, [angles[0]]))  # for closing the polygon

fig, ax = plt.subplots(figsize=(12, 12), subplot_kw=dict(polar=True))
ax.grid(color="gray", linestyle="--", linewidth=0.5, alpha=0.7)

# Color mapping for each simulator column
color_map = {
    "Qiskit-MPS": "#1f77b4",
    "QMatchaTea-MPS": "#2ca02c",
    "MQT-DDS": "#17becf",
    "Quimb-MPS": "#d62728",
    "Quimb-TN": "#9467bd",   
    "MIMIQ-MPS": "#ff7f0e",
    "Pyqrack": "#e377c2"  
}

# Marker shapes mapping for each simulator column
marker_shapes = {
    "Qiskit-MPS": "o",
    "QMatchaTea-MPS": "s",
    "MQT-DDS": "D",
    "Quimb-MPS": "^",
    "Quimb-TN": "v",   
    "MIMIQ-MPS": "h",
    "Pyqrack": "*"  
}

# Global dictionary to track overlapping marker occurrences.
point_counts = {}

for col in simulator_cols:
    current_color = color_map.get(col, "#000000")  # fallback to black if missing
    marker = marker_shapes.get(col, "o")  # get the marker shape
    edge_color = darken_color(current_color, factor=0.8)  # slightly darker for the frame

    # Get raw column values and replace NaNs with a very small number.
    values = df[col].tolist()
    values = np.nan_to_num(np.array(values), nan=1e-6)
    values_closed = np.concatenate((values, [values[0]]))
    
    # Draw filled polygon with boundary color same as line color.
    ax.fill(angles_closed, values_closed, facecolor=current_color, edgecolor=current_color, alpha=0.15, zorder=3)
    
    # Plot the connecting line.
    ax.plot(angles, values, color=current_color, linewidth=2.5, zorder=5)
    ax.plot([angles[-1], angles[0]], [values[-1], values[0]], color=current_color, linewidth=2.5, zorder=5)
    
    # Plot markers and adjust for overlaps only within the same series.
    for j, r in enumerate(values):
        # Skip marker if the value is the default 1e-6 - in some cases to remove the unwanted center point.
        if np.isclose(r, 1e-6, atol=1e-8):
            continue
            
        key = (col, angles[j], r)
        shift = point_counts.get(key, 0)
        point_counts[key] = shift + 1

        adjusted_r = r + shift * 10  # slight vertical shift per overlap
        adjusted_angle = angles[j]
        if r == 1024:  # apply a small horizontal shift for specific values
            adjusted_angle += shift * 0.02
        # Marker with frame (edge color) slightly darker than line color.
        ax.scatter(adjusted_angle, adjusted_r, color=current_color, marker=marker, s=100, edgecolors=edge_color, linewidths=1.5, zorder=7)

ax.set_yscale('symlog', linthresh=30, linscale=1)
tick_values = [0, 10, 30, 50, 100, 250, 500, 1024]
ax.set_yticks(tick_values)
ax.set_yticklabels([str(t) for t in tick_values], fontsize=12, fontweight="bold", color="black")
ax.set_ylim(0, 1350)

ax.set_xticks(angles)
ax.set_xticklabels(alg_labels, fontsize=12, fontweight="bold")

# Create custom legend handles that include both color and marker shape with matching edge colors.
legend_elements = []
for col in simulator_cols:
    current_color = color_map.get(col, "#000000")
    marker = marker_shapes.get(col, "o")
    edge_color = darken_color(current_color, factor=0.8)
    legend_elements.append(Line2D([0], [0],
                                  color=current_color,
                                  marker=marker,
                                  markersize=10,
                                  label=col,
                                  markerfacecolor=current_color,
                                  markeredgecolor=edge_color))

ax.legend(handles=legend_elements, loc="upper right", bbox_to_anchor=(1.25, 1.1), fontsize=12)
plt.tight_layout()

plt.savefig("radar_chart.png", dpi=300, bbox_inches="tight")
plt.close()




